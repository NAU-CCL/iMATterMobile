{"ast":null,"code":"import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DEFAULT_OPTIONS = {\n  includeMetadataChanges: false\n};\n\nfunction fromRef(ref, options) {\n  if (options === void 0) {\n    options = DEFAULT_OPTIONS;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n\n\n  return new Observable(function (subscriber) {\n    var unsubscribe = onSnapshot(ref, options, {\n      next: subscriber.next.bind(subscriber),\n      error: subscriber.error.bind(subscriber),\n      complete: subscriber.complete.bind(subscriber)\n    });\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction doc(ref) {\n  return fromRef(ref, {\n    includeMetadataChanges: true\n  });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\n\n\nfunction docData(ref, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, options);\n  }));\n}\n\nfunction snapToData(snapshot, options) {\n  if (options === void 0) {\n    options = {};\n  } // TODO clean up the typings\n\n\n  var data = snapshot.data(); // match the behavior of the JS SDK when the snapshot doesn't exist\n  // it's possible with data converters too that the user didn't return an object\n\n  if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n    return data;\n  }\n\n  if (options.idField) {\n    data[options.idField] = snapshot.id;\n  }\n\n  return data;\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\n\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n\n    return hasChange;\n  });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\n\n\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\n\n\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\n\n\nvar windowwise = function () {\n  return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\n\n\nvar metaDataEquals = function (a, b) {\n  return JSON.stringify(a.metadata) === JSON.stringify(b.metadata);\n};\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\n\n\nvar filterEmptyUnlessFirst = function () {\n  return pipe(windowwise(), filter(function (_a) {\n    var prior = _a[0],\n        current = _a[1];\n    return current.length > 0 || prior === undefined;\n  }), map(function (_a) {\n    _a[0];\n    var current = _a[1];\n    return current;\n  }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\n\n\nfunction collectionChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(windowwise(), map(function (_a) {\n    var priorSnapshot = _a[0],\n        currentSnapshot = _a[1];\n    var docChanges = currentSnapshot.docChanges();\n\n    if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n      // the metadata has changed, docChanges() doesn't return metadata events, so let's\n      // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n      // since either this docChanges() emission or the prior snapshot\n      currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n        var currentDocChange = docChanges.find(function (c) {\n          return refEqual(c.doc.ref, currentDocSnapshot.ref);\n        });\n\n        if (currentDocChange) {\n          // if the doc is in the current changes and the metadata hasn't changed this doc\n          if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n            return;\n          }\n        } else {\n          // if there is a prior doc and the metadata hasn't changed skip this doc\n          var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n            return refEqual(d.ref, currentDocSnapshot.ref);\n          });\n\n          if (priorDocSnapshot && metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n            return;\n          }\n        }\n\n        docChanges.push({\n          oldIndex: currentIndex,\n          newIndex: currentIndex,\n          type: 'modified',\n          doc: currentDocSnapshot\n        });\n      });\n    }\n\n    return docChanges;\n  }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction collection(query) {\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction sortedChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collectionChanges(query, options).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, options.events);\n  }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\n\n\nfunction auditTrail(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collectionChanges(query, options).pipe(scan(function (current, action) {\n    return __spreadArray(__spreadArray([], current), action);\n  }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\n\n\nfunction collectionData(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, options);\n    });\n  }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges }; //# sourceMappingURL=index.esm.js.map","map":null,"metadata":{},"sourceType":"module"}