{"ast":null,"code":"var _a;\n\nimport { __awaiter, __decorate, __metadata } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { AngularFirestore } from '@angular/fire/firestore';\nimport { map } from 'rxjs/operators';\nimport { BehaviorSubject } from 'rxjs';\nimport { Storage } from '@ionic/storage';\nimport * as firebase from 'firebase/app';\nimport 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/scan';\nimport 'rxjs/add/operator/take';\nlet ChatService = class ChatService {\n  constructor(afs, storage) {\n    this.afs = afs;\n    this.storage = storage;\n    this.doneLoadingChats = new BehaviorSubject(false); // Done loading chats.\n\n    this.loadingChats = new BehaviorSubject(false); // are we currently waiting on chats to load?\n\n    this.currentChatDataBatch = new BehaviorSubject([]); // last batch of chats returned from firestore.\n    //Observable Data\n\n    this.doneLoadingChatsObs = this.doneLoadingChats.asObservable(); // loaded all chats\n\n    this.loadingChatsObs = this.loadingChats.asObservable(); // currently loading chats.\n\n    this.cohortCollection = this.afs.collection('cohorts');\n    this.cohorts = this.cohortCollection.snapshotChanges().pipe(map(actions => {\n      return actions.map(a => {\n        const data = a.payload.doc.data();\n        data.id = a.payload.doc.id;\n        return data;\n      });\n    })); //this.deleteBlankChats();\n    //this.initializeDateChats();\n    //this.addIsInChatFieldToUsers();\n  }\n\n  getChats(cohortID) {\n    this.getChatCollection(cohortID); // this.iterateChats(cohortID);\n\n    return this.chats;\n  }\n\n  getChatCollection(cohortID) {\n    // this.iterateChats(cohortID);\n    console.log(`getting chats, cohort id is ${cohortID}`);\n    this.chatCollection = this.afs.collection('chats', reference => reference.where('cohort', '==', cohortID).orderBy('timestamp'));\n    this.chats = this.chatCollection.snapshotChanges().pipe(map(actions => {\n      return actions.map(a => {\n        const data = a.payload.doc.data();\n        data.id = a.payload.doc.id;\n        return data;\n      });\n    }));\n  }\n\n  addChat(newChat) {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log(`Adding chat. Chat to be added is ${JSON.stringify(newChat)}`); // Add the new chat to the database.\n\n      this.afs.collection('chats').add(newChat);\n    });\n  }\n\n  deleteChat(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.chatCollection.doc(id).delete();\n    });\n  }\n\n  updateChatVisibility(docID, bool) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (bool === false) {\n        return this.afs.firestore.collection('chats').doc(docID).update({\n          visibility: false\n        });\n      } else {\n        return this.afs.firestore.collection('chats').doc(docID).update({\n          visibility: true\n        });\n      }\n    });\n  }\n\n  updateChatNumberCounter(docID, num) {\n    return this.afs.firestore.collection('chats').doc(docID).update({\n      count: num\n    });\n  }\n  /* This function iterates through all chats in a cohort to decide if they are visible to the user or not */\n\n\n  iterateChats(cohortID, timeCalled) {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log('iterateChats called'); // get what the admin has set to determine user visibility of chats\n\n      firebase.firestore().collection('settings').doc('chatroomSettings').get().then(result => {\n        const lifeType = result.get('lifeType'); // if chat visibility is based on number of hours the chat has existed\n\n        if (lifeType === 'hours') {\n          // get admin set time for chats to last\n          let setHours = result.get('hours'); // convert to ms\n\n          setHours = setHours * 60 * 60 * 1000; // get todays date\n\n          const now = new Date();\n          console.log('now', now); // go into all chats\n\n          const ref = firebase.firestore().collection('chats').where('cohort', '==', cohortID);\n          ref.get().then(res => {\n            res.forEach(doc => {\n              const timestamp = new Date(doc.get('timestamp').toDate()); // check difference between the time the chat was sent and now\n\n              const difference = now.getTime() - timestamp.getTime(); // if this difference is greater than set hours, set visibility to false. Otherwise, true\n\n              if (difference >= setHours) {\n                this.updateChatVisibility(doc.id, false);\n              } else {// can be used to set chats back to true for testing purposes\n                // this.updateChatVisibility(doc.id, true);\n              }\n            });\n          }); // check if the type is based on number of chats in the room\n        } else if (lifeType === 'number') {\n          // get the number admin has set\n          const numChatsVis = result.get('numberOfChats');\n          let numberOfCurrentChats = 0;\n          let numberOfCurrentAutoChats = 0; // time order is oldest to newest\n\n          const ref = firebase.firestore().collection('chats').where('cohort', '==', cohortID).orderBy('timestamp', 'desc');\n          ref.get().then(res => {\n            res.forEach(doc => {\n              // for each doc in the cohort chat room, if it is a user sent, iterate\n              if (doc.get('type') === 'user' && doc.get('visibility') === true) {\n                // count the number of non-auto chats\n                numberOfCurrentChats += 1; // assign a new number to each chat\n\n                this.updateChatNumberCounter(doc.id, numberOfCurrentChats);\n\n                if (timeCalled === 'ngOnInit' || timeCalled === 'ionViewWillLeave') {\n                  if (doc.get('count') > numChatsVis) {\n                    this.updateChatVisibility(doc.id, false);\n                  }\n                } else if (timeCalled === 'addChat') {\n                  if (doc.get('count') > numChatsVis - 1) {\n                    this.updateChatVisibility(doc.id, false);\n                  }\n                }\n              } else if (doc.get('type') === 'emotion' || doc.get('type') === 'auto') {\n                if (doc.get('visibility') === true) {\n                  // count the number of auto chats\n                  numberOfCurrentAutoChats += 1; // assign a new number to each chat\n\n                  this.updateChatNumberCounter(doc.id, numberOfCurrentAutoChats);\n\n                  if (timeCalled === 'ngOnInit' || timeCalled === 'ionViewWillLeave') {\n                    if (doc.get('count') > numChatsVis) {\n                      this.updateChatVisibility(doc.id, false);\n                    }\n                  } else if (timeCalled === 'addChat') {\n                    if (doc.get('count') > numChatsVis - 1) {\n                      this.updateChatVisibility(doc.id, false);\n                    }\n                  }\n                }\n              }\n            });\n          });\n        }\n      });\n    });\n  } // Deletes all chats from 'chats' collection in the db.\n\n\n  deleteAllChats() {\n    this.afs.collection('chats').ref.get().then(querySnap => {\n      querySnap.forEach(queryDocSnap => {\n        queryDocSnap.ref.delete();\n      });\n    });\n  } // Delete all chats in db that are blank. ie every single field is an empty string.\n  // Not sure where these chats come from at the moment but they start to pile up over time.\n\n\n  deleteBlankChats() {\n    let chatCount = 1;\n    this.afs.collection('chats').ref.where('type', '==', '').get().then(querySnap => {\n      querySnap.forEach(queryDocSnap => {\n        let chatDoc = queryDocSnap.data();\n        console.log(`Chat to delete is ${JSON.stringify(chatDoc)} \\n\\n Total chats ${chatCount}`);\n        chatCount++;\n        queryDocSnap.ref.delete();\n      });\n    });\n  } // Initialize the chat service that fetches old chat messgaes. Likely over complicated, and \n  // I can not explain how everything works but note the startAt function. This is used to access\n  // documents from some index in a collection, can use this to only fetch all document after index n in a collection for example,\n  // works great for fetching chats because we need to keep track of what index we have fetched messages from last.\n  // Can probably be used to create a much simpler function.\n\n\n  initChatServce(path, field, opts) {\n    this.query = Object.assign({\n      path,\n      field,\n      limit: 30,\n      reverse: true,\n      prepend: true\n    }, opts); // order by desc if reverse is true.\n\n    const first = this.afs.collection(this.query.path, ref => {\n      return ref.orderBy(this.query.field, this.query.reverse ? 'desc' : 'asc').limit(this.query.limit);\n    });\n    this.mapAndUpdate(first); // SCan allows us to build a larger array over time.\n    // Convert our chat batch subject to an observable and save it into the current batch obs variable.\n\n    this.currentChatDataBatchObs = this.currentChatDataBatch.asObservable().scan((acc, val) => {\n      return this.query.prepend ? val.concat(acc) : acc.concat(val);\n    });\n  }\n\n  mapAndUpdate(chatCollection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Dont run this function if weve loaded all chats in the db, or if were already loading chats.\n      if (this.loadingChats.value || this.doneLoadingChats.value) {\n        return;\n      }\n\n      ;\n      this.loadingChats.next(true);\n      return chatCollection.snapshotChanges().do(array => {\n        let values = array.map(snapShot => {\n          const data = snapShot.payload.doc.data();\n          const doc = snapShot.payload.doc;\n          return Object.assign(Object.assign({}, data), {\n            doc\n          });\n        });\n        values = this.query.prepend ? values.reverse() : values;\n        this.currentChatDataBatch.next(values);\n        this.loadingChats.next(false); // If length is 0, execute if statement. Means we have loaded all chats\n        // because the values array has a length of 0.\n\n        if (!values.length) {\n          // Found all chats. No more chats to load.\n          this.doneLoadingChats.next(true);\n        }\n      }).take(1).subscribe();\n    });\n  }\n\n  getCursor() {\n    const current = this.currentChatDataBatch.value;\n\n    if (current.length) {\n      return this.query.prepend ? current[0].doc : current[current.length - 1].doc; // add to end or beginning of the observable.\n    }\n\n    return null;\n  }\n\n  more() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cursor = this.getCursor();\n      const more = this.afs.collection(this.query.path, ref => {\n        return ref.orderBy(this.query.field, this.query.reverse ? 'desc' : 'asc').limit(this.query.limit).startAfter(cursor);\n      });\n      yield this.mapAndUpdate(more);\n    });\n  } // Gets all chats from the db that are added after the user joins the chatroom.\n  // Snapshots any changes so the returned observable can fetch new messages from the db.\n  // Consider using state changes for the instead of snapshot changes for new chats.\n\n\n  getNewChats(cohortID) {\n    // this.iterateChats(cohortID);\n    let currentDateAndTime = new Date();\n    console.log(`Getting current chats, current date is ${currentDateAndTime}`);\n    this.chatCollection = this.afs.collection('chats', reference => reference.where('timestamp', '>', currentDateAndTime));\n    return this.chats = this.chatCollection.snapshotChanges().pipe(map(actions => {\n      return actions.map(a => {\n        const data = a.payload.doc.data(); // payload is a property of DocumentChange object.\n        //Return the data object for the chat object.\n\n        return data;\n      });\n    }));\n  } // One off function to create a bunch of test chats in the chat room as I accidentally deleted them all.\n\n\n  createTestChats() {\n    let index = 0;\n\n    while (index < 30) {\n      this.afs.collection('chats').add({\n        cohort: 'default',\n        userID: 'NTw38h',\n        message: 'test',\n        username: 'calvin',\n        profilePic: 'https://firebasestorage.googleapis.com/v0/b/imatter-nau.appspot.com/o/ProfileImages%2Fpeacock.png?alt=media&token=ba0dd515-3350-4258-a615-5d76ec48e9ef',\n        timestamp: new Date(),\n        visibility: true,\n        type: 'user',\n        count: 0\n      });\n      index++;\n    }\n  } // Adds a new auto chat to the autoChats collection\n\n\n  addAutoChat(newChat, userCode, isEmotionChat = false) {\n    this.afs.collection('autoChats').add(newChat);\n\n    if (!isEmotionChat) {\n      // Query database for the user document and change the users chat status to active or non active \n      // depending on whether the user is actively in the chat.\n      this.afs.collection('users').ref.where('code', '==', userCode).get().then(querySnapshot => {\n        querySnapshot.forEach(docSnap => {\n          // Get doc reference so we can call update on it.\n          let userDocRef = docSnap.ref;\n\n          if (newChat.type == 'entered') {\n            userDocRef.update({\n              isInChat: true\n            });\n          } else {\n            userDocRef.update({\n              isInChat: false\n            });\n          }\n        });\n      });\n    } else {\n      console.log(`Auto chat was emotion`);\n    }\n  }\n\n  getAutoChats() {\n    let currentDate = new Date(); // Return all new or edited documents. In this case, should only return new docs as they are never edited.\n    // stateChanges vs snapshotChanges. snapshotChanges reexecutes the query each time a document in the database changes. This would be good\n    // for refreshing a list of data that the user can see, but we only want a single autochat document so we use stateChanges. Statechanges only returns a single document from the database on change.\n\n    return this.afs.collection('autoChats', ref => ref.where('timestamp', '>', currentDate)).stateChanges();\n  }\n\n  deleteAllAutoChats() {\n    this.afs.collection('autoChats').ref.get().then(querySnap => {\n      querySnap.forEach(queryDocSnap => {\n        queryDocSnap.ref.delete();\n      });\n    });\n  }\n\n  getAutoChatSettings() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.afs.collection('settings').ref.doc('chatroomSettings');\n    });\n  }\n\n};\nChatService = __decorate([Injectable({\n  providedIn: 'root'\n}), __metadata(\"design:paramtypes\", [typeof (_a = typeof AngularFirestore !== \"undefined\" && AngularFirestore) === \"function\" ? _a : Object, Storage])], ChatService);\nexport { ChatService };","map":null,"metadata":{},"sourceType":"module"}